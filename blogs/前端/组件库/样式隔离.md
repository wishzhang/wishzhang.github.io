---

title: 样式隔离
date: 2023-08-12
tags: 

- css

categories:

 - 前端

---



## 单一项目的情况

先搞清楚为什么需要样式隔离，什么情况会需要样式隔离？
系统的结构是一棵组件树，单个组件拥有自己的内部样式，内部样式不应该去影响其它组件的样式，对于系统的公共样式是会影响多个组件的样式，不过这也是符合期望的，在有一个项目做到这些就满足开发需求了，并不需要进行样式隔离。

但在一个项目引入第三方组件的时候，就可能会出现样式冲突的问题，导致的结果是，项目意外地影响了第三方组件的样式、第三方组件意外地影响了项目的样式，这是一种常见的情况。

**解决这种情况的方法是：**

- **对单个组件样式隔离，比如vue组件使用scoped**
- **对所有全局样式隔离，比如让所有的css类名不相同（不只是命名空间，而是所有css类名）**
- **在上面的前提下对特殊样式的特殊处理，比如对含有fixed样式的元素插入到body直接子元素**

举个例子，比如项目引进element-ui组件库，那么这个element-ui组件库就通过scoped，bem命名法，提供将弹窗插入到body子元素的方法来实现样式隔离，是element-ui不能影响项目的样式。对于项目而言也应当如此，只是一般来说项目还会对公共样式，element-ui组件样式进行预期的自定义修改，scoped为这也留了口子，element-ui提供了全局css变量，项目也可以在公共样式来统一修改element-ui的样式，这些都是预期的没什么问题。

所以第三方组件能满足上面的三点约束，就能解决常见情况的样式隔离问题了。这三点约束也是解决目前所有样式隔离的主要方法。



## 多项目多组件库的情况

再来看看另外一种情况，第三方组件是基于基础组件包装的组件，而项目引入第三方组件并且也引进了基础组件，那么双方的全局样式就很可能要互相影响了，哈哈哈又是全局样式。但像这种第三方组件通常有两种应用场景：

1. 完全不改变基础组件样式，并且不把基础组件打包，不过这需要项目自身来引入基础组件

2. 将基础组件打包进去（或引用自带基础组件的依赖），不存在全局污染样式，项目自身的基础组件和第三方里的基础组件也是互不影响

第一种简单好理解好处理。但考虑第二种应用场景是项目舍弃了对第三方组件的基础组件样式的统一控制，意味着第三方组件和里面的基础组件是融为一体的独立的了，其所有样式不应该影响项目。但关键的让人头疼的问题来了，就是开发人员容易处理不好第三方组件的样式把全局样式暴露在全局命名空间上。比如下面的代码：

```js
// main.js
import './index.scss'
import './index.css'
```

```vue
// A.vue
<script>
  import './my.scss'
  import './my2.css'
</script>

<style lang="scss">
	@import "./my3.scss";
  @import "./my4.css"
</style>
```

以上的代码每个都会在html页面上插入一个style标签。按理我们要使所有css类命名不同，但基础组件的名字通常我们不能改动，由此css类名重名导致样式互相影响的问题就来了，这个问题在同一个iframe下是无法彻底隔离的。在这种情况下目前我们勉强能做到的是：让第三方基础组件的样式不影响项目的样式，但项目的样式可以影响第三方基础组件样式（可控的）。方法是：

1. 解决的思想是：给所有第三方组件的样式名加上命名空间
2. 第一点会造成弹窗样式命中不了，需要额外的修复，也是通过命名空间来修复。第三方组件的弹窗应当不使用公共样式并且不修改原来样式，这样可以不加命名空间，这是理想的情况；如果使用了则需要给弹窗加命名空间，但这会使得弹窗根元素的自定义样式和弹窗的少量样式没有靶子而失效

对于第一点的实现方法有两种：

- 使用postcss转换器为其所有css类名添加命名空间

- 使用css预处理器将全局样式文件放到一个命名空间下，如：

```scss
.namespace {
  @import "./global.scss";
}
```

对于第二点的实现方法是，监听插入到body的直接子元素，动态添加命名空间。对于第三方组件失效的样式需要手动添加其命名空间。

这样就让第三方组件样式不影响项目样式了自然也不影响项目引入的其他第三方组件样式，而项目样式可以影响第三方组件样式这个是预期的正常的。











