---

title: 作用域和闭包
date: 2021-09-21
tags: 

- JavaScript

categories:

 - 前端

---

## 1 作用域

>世界的来源：世界是人类观察的世界，我处在的世界是我所观察领悟到的世界。
>世界是什么：人类所领悟到的知识归类为学科，再运用知识去解决问题，相当于于一张无限的概率节点图。
>人类将事物抽象成大小不同粒度的模块，那么作用域是模块的本身属性，即模块的有效范围，是必要的。

### 1.1 编译原理
源代码在执行之前会经历三个步骤，统称为“编译”。

1. 分词/词法分析
2. 解析/语法分析
3. 代码生成

### 1.2 词法作用域
JavaScript采用词法作用域(lexical scoping), 也就是静态作用域。
静态作用域在编译时就确定了，动态作用域是在运行时确定的。

### 1.3 函数作用域和块作用域
函数作用域的含义指，属于这个函数的全部变量都可以在整个函数的范围内使用。
块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。

### 1.4 提升

我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。

变量提升规则：
- var 和函数声明可以变量提升，函数声明优先于var
- var 变量提升值赋值undefined, 函数声明优先于var
- 函数声明重复声明会覆盖
const和let声明：
- 不存在变量提升
- 不能重复声明
- 作用域死区，变量使用前必须先声明
- const声明，如果值类型不可修改，引用类型地址不可修改


### 1.5 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。

### 1.6 异常

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。

如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。


## 2 闭包
> 函数在当前词法作用域之外的地方**执行时**，可以记住并访问所在的词法作用域，这时就产生了闭包。闭包是基于垃圾回收和作用域链的机制产生的一种现象。

### 2.1 执行环境和作用域链
>当某个函数被调用时，会创建一个执行环境以及相应的作用域链。执行环境分为全局执行环境和局部执行环境。
>作用域链本质上是一个指向作用域对象的链表。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。

```javascript
<script>
  debugger;
  let a = 'here is global';

  debugger;

  function second() {
    let b = 'here is b';
    debugger;

    function third() {
      debugger;
      let c = 'here is c';
    }
  }

  debugger;

  second();

  debugger;

</script>
```
浏览器的调试工具会把函数调用栈、函数可访问的变量都列出来
![8188e4719fe0570282abc23c87285675.png](/assets/zuoyongyu_bibao.png)


***
## 3 应用

作用域和闭包的理论了解就这么多啦，毕竟没有看源码不知道太细节的逻辑，但大致的理论能够保证是正确的。
应用作用域和闭包的思想就是，根据词法作用域访问变量，然后了解变量的引用情况去做详细设计编码，遇到难以解决的问题就打开控制台查看具体的堆栈，闭包等信息。

下面列举一些最佳实践：

*  函数柯里化
*  缓存的方法
*  工厂模式
*  面向对象封装
*  延迟使用