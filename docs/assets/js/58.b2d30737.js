(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{472:function(t,e,s){"use strict";s.r(e);var r=s(2),n=Object(r.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("面向对象、面向服务、模块化、基于构件、组件化等等的名词我们都听的很多了，对于系统设计的全过程其实只运用了抽象与具体的转换逻辑、模块与模块之间的逻辑，对一个具体的问题再某些层面上达到逻辑链严谨，从而解决问题。说白了是一张图，废话真多。诶，具体还需要在一个具体工程上得到最佳实践才行。")]),this._v(" "),t("h2",{attrs:{id:"vue的组件化实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的组件化实现"}},[this._v("#")]),this._v(" Vue的组件化实现")]),this._v(" "),t("p",[this._v("Vue通过模板编译得到一个render函数，render函数是通过createElement函数来创建VNode。如果tag是组件选项则通过createComponent函数来创建VNode, 通过原型继承Vue构造函数得到子组件的构造函数。子组件的生命周期会在父组件的patch过程中调用，通过深度递归的方式去渲染整个组件树。")])])}),[],!1,null,null,null);e.default=n.exports}}]);